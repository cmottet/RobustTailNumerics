###
a <- qlnorm(0.7,meanlog,sdlog)
eta <- dlnorm(a,meanlog,sdlog)
beta <- 1 - plnorm(a,meanlog,sdlog)
nu <- -DistributionPty::Dlnorm(a,2,meanlog,sdlog) # As second derivative of the distribution function
mu <- eta/nu
sigma <- 2*beta/nu
###
### Parameters of the news vendor problem
###
price <- 7
cost  <- 1
###
### Create the data for the plot
###
# Get the results of Equation (17)  for a given q
load("data/runNewsVendorLogNormal.RData")
q <- optimBound$q
term1 <- optimBound$term1
dataPlot <- select(optimBound, q, term1, value = bound)
dataPlot <- transform(dataPlot, method = "Optimal Upper Bound")
# Equation (17)  for the true log normal distribution
term21 <- q*(1 - plnorm(pmax(q,a), meanlog,sdlog))
term22 <- (partialExpectationlnorm(q, meanlog,sdlog) -  partialExpectationlnorm(a, meanlog,sdlog))*(q >=a)
term2 <- price*(term21 + term22)
dataPlot <- rbind(dataPlot, data.frame(q, term1, value = term1 + term2, method = "Log-normal Density"))
# Equation (17)  for some 2-PLT feasible solution of program (2)
P <- RobustTail::getDistribution(mu,sigma, x1 = mu/5)
term2 <- sapply(q, function(q) {
H <- function(x) {
M <- pmax(q-a,0)
mx <- pmin(x,q-a)
term1 <- q/2*(x-M)^2*(x > M)
term2 <- (1/6*(mx+a)^3 - 1/6*a^3  -x*a^2/2 + q^2/2*(x +a -q)*(x + a > q))*(mx >= 0)
price*(term1 + term2)
}
with(P, nu*(p[1]*H(x[1]) + p[2]*H(x[2])))
})
dataPlot <- rbind(dataPlot, data.frame(q, term1, value = term1 + term2, method = "2-PLT"))
# Equation (17) for some mixture of shifted pareto and 2-PLT feasible solution of program (2)
source("R/extras.R")
mixture <- fitMixturePareto2PLT(a,nu,eta,beta, seed=200)
#  PLT term of the objective value
H <- function(x) {
M <- pmax(q-a,0)
mx <- pmin(x,q-a)
term1 <- q/2*(x-M)^2*(x > M)
term2 <- (1/6*(mx+a)^3 - 1/6*a^3  -x*a^2/2 + q^2/2*(x + a -q)*(x + a >= q))*(mx >= 0)
output <-  price*(term1 + term2)
return(output)
}
term2PLT <- with(mixture$PLT, nu*(p[1]*H(x[1]) + p[2]*H(x[2])))
# Pareto term of the objective value
set.seed <- 100 ; D <- with(mixture$Pareto, rpareto(n = 1e5, scale, shape))
grid <- expand.grid(q = q, D = D )
term2Pareto <- ddply(grid, .(q), function(data) with(data, price*(mean(pmin(q,D)*(D >= a)))))$V1
term2 <- with(mixture, PLT$w*term2PLT + Pareto$w*term2Pareto)
dataPlot <- rbind(dataPlot, data.frame(q, term1, value = term1 + term2, method = "Mixture of Pareto and 2-PLT"))
# Visualize bound
bitmap("pics/newsVendor_bound_logNorm_70th_percentile.tiff",res = 300, width = 5,height = 5)
library(grid)
library(ggplot2)
plot <- ggplot(dataPlot, aes(x = q, y = value)) +
geom_line(aes(linetype = method)) +
labs(x = "q", y = "Expected Profit", linetype = "") +
geom_vline(xintercept = a, linetype = "dashed") +
theme(legend.position = c(1/2, 1/8))
gtext <-textGrob("a", y = -0.02)
plot <- ggplotGrob(plot + annotation_custom(gtext,xmin = 29, xmax = 29, ymin = -Inf, ymax = Inf))
plot$layout$clip[plot$layout$name=="panel"] <- "off"
grid.draw(plot)
dev.off()
# The command below only works for Mac OS X systems
# It converts to a png format without loss
# system("sips -s format png pics/newsVendor_bound_logNorm_70th_percentile.tiff --out pics/newsVendor_bound_logNorm_70th_percentile.png") # To convert in a png format without loss
ggsave(plot,file = "pics/Figure10_newsVendor_bound_logNorm_70th_percentile.svg", width = 5,height = 5,dpi=300)
remove(list = ls())
library(svglite)
library(ggplot2)
library(plyr)
library(dplyr)
# Load data
load("data/syntDatalogNormal.RData")
meanlog <- 0
sdlog <- 0.5
###
### Get the data for Figure 12, i.e. the 95% confidence intervals
### for eta, nu, and beta
###
a <- seq(0.8,5, length =100)
load("data/syntDatalogNormalCI.RData")
dataPlot <- NULL
for (i in 1:length(CI))
{
a <- CI[[i]]$a
truth <- c(DistributionPty::Dlnorm(a,2,meanlog,sdlog),
DistributionPty::Dlnorm(a,1,meanlog,sdlog),
1 - plnorm(a,meanlog,sdlog))
newDataPlot <- data.frame(a = a,
parameter = rep(c("Density derivative function", "Density function", "Tail distribution function"),3),
value = as.numeric(c(CI[[i]]$hyperrectangle[1,], CI[[i]]$hyperrectangle[2,], truth)),
group =  rep(c("lB","uB","truth"),each = 3),
type = c(rep("Boostrap 95% CI", 6), rep("True function",3)))
dataPlot <- rbind(dataPlot, newDataPlot)
}
##
## Plot CI's
##
bitmap("pics/FitKEModelLogNorm.tiff",res = 300, width = 5,height = 5)
library(ggplot2)
plot<-ggplot(dataPlot, aes(x = a, y  = value, group = group)) +
geom_line(aes(linetype = type)) +
labs(y = "", linetype = "", x = "") +
facet_wrap(~parameter, ncol = 2, scales = "free") +
theme(legend.position = c(7/8, 1/8), legend.justification = c(1, 0))
dev.off()
# The command below only works for Mac OS X systems
# It converts to a png format without loss
# system("sips -s format png pics/FitKEModelLogNorm.tiff --out pics/FitKEModelLogNorm.png")
ggsave(plot,file = "pics/Figure12_FitKEModelLogNorm.svg", width = 5,height = 5,dpi=300)
Dlnorm(a,1,meanlog,sdlog)
a
# Load data
load("data/syntDatalogNormal.RData")
meanlog <- 0
sdlog <- 0.5
###
### Get the data for Figure 12, i.e. the 95% confidence intervals
### for eta, nu, and beta
###
a <- seq(0.8,5, length =100)
###
### Reformat CI as a data frame
###
dataPlot <- NULL
for (i in 1:length(CI))
{
a <- CI[[i]]$a
truth <- c(DistributionPty::Dlnorm(a,2,meanlog,sdlog),
DistributionPty::Dlnorm(a,1,meanlog,sdlog),
1 - plnorm(a,meanlog,sdlog))
newDataPlot <- data.frame(a = a,
parameter = rep(c("Density derivative function", "Density function", "Tail distribution function"),3),
value = as.numeric(c(CI[[i]]$hyperrectangle[1,], CI[[i]]$hyperrectangle[2,], truth)),
group =  rep(c("lB","uB","truth"),each = 3),
type = c(rep("Boostrap 95% CI", 6), rep("True function",3)))
dataPlot <- rbind(dataPlot, newDataPlot)
}
Dlnorm(a,1,meanlog,sdlog)
a
###
### Reformat CI as a data frame
###
dataPlot <- NULL
for (i in 1:length(CI))
{
a <- CI[[i]]$a
truth <- c(DistributionPty::Dlnorm(a,2,meanlog,sdlog),
DistributionPty::Dlnorm(a,1,meanlog,sdlog),
1 - DistributionPty::Dlnorm(a,0,meanlog,sdlog))
newDataPlot <- data.frame(a = a,
parameter = rep(c("Density derivative function", "Density function", "Tail distribution function"),3),
value = as.numeric(c(CI[[i]]$hyperrectangle[1,], CI[[i]]$hyperrectangle[2,], truth)),
group =  rep(c("lB","uB","truth"),each = 3),
type = c(rep("Boostrap 95% CI", 6), rep("True function",3)))
dataPlot <- rbind(dataPlot, newDataPlot)
}
##
## Plot CI's
##
library(ggplot2)
plot<-ggplot(dataPlot, aes(x = a, y  = value, group = group)) +
geom_line(aes(linetype = type)) +
labs(y = "", linetype = "", x = "") +
facet_wrap(~parameter, ncol = 2, scales = "free") +
theme(legend.position = c(7/8, 1/8), legend.justification = c(1, 0))
plot
a
meanlog <- 0
sdlog <- 0.5
remove(list = ls())
library(svglite)
library(ggplot2)
library(plyr)
library(dplyr)
load("data/syntDatalogNormal.RData")
meanlog <- 0
sdlog <- 0.5
a <- seq(0.8,5, length =100)
load(file = "data/syntDatalogNormalCI.RData")
dataPlot <- NULL
for (i in 1:length(CI))
{
a <- CI[[i]]$a
truth <- c(DistributionPty::Dlnorm(a,2,meanlog,sdlog),
DistributionPty::Dlnorm(a,1,meanlog,sdlog),
1 - DistributionPty::Dlnorm(a,0,meanlog,sdlog))
newDataPlot <- data.frame(a = a,
parameter = rep(c("Density derivative function", "Density function", "Tail distribution function"),3),
value = as.numeric(c(CI[[i]]$hyperrectangle[1,], CI[[i]]$hyperrectangle[2,], truth)),
group =  rep(c("lB","uB","truth"),each = 3),
type = c(rep("Boostrap 95% CI", 6), rep("True function",3)))
dataPlot <- rbind(dataPlot, newDataPlot)
}
ggplot(dataPlot, aes(x = a, y  = value, group = group)) +
geom_line(aes(linetype = type)) +
labs(y = "", linetype = "", x = "") +
facet_wrap(~parameter, ncol = 2, scales = "free") +
theme(legend.position = c(7/8, 1/8), legend.justification = c(1, 0))
length(CI)
CI[[30]]
i=30
CI[[i]]$a
a <- CI[[i]]$a
truth <- c(DistributionPty::Dlnorm(a,2,meanlog,sdlog),
DistributionPty::Dlnorm(a,1,meanlog,sdlog),
1 - DistributionPty::Dlnorm(a,0,meanlog,sdlog))
truth
DistributionPty::Dlnorm(a,0,meanlog,sdlog)
meanlog
sdlog
DistributionPty::Dlnorm(0,0,meanlog,sdlog)
remove(list = ls())
library(svglite)
library(plyr)
library(dplyr)
library(ggplot2)
# Load Danish insurance fire data
load("data/datafireinsurance.RData")
sample <- as.numeric(sample$Loss.in.DKM)
amax <- sort(sample)[length(sample) -15]
- seq(1, amax, length = 50)
CI
a <- seq(1, amax, length = 50)
load("data/datafireinsuranceCI.RData")
dataPlot <- NULL
for (i in 1:length(CI))
{
bootSample <- CI[[i]]$bootSample
newDataPlot <- data.frame(a =  CI[[i]]$a,
parameter = rep(c("Density derivative function", "Density function", "Tail distribution function"),3),
value =  as.numeric(c(CI[[i]]$hyperrectangle[1,], CI[[i]]$hyperrectangle[2,], as.numeric(apply(bootSample,2,mean)))),
group = rep(c("lB", "uB", "Fhat"),each  = 3),
type = c(rep("Boostrap 95% CI", 6),rep("Boostraped estimated function", 3) ))
dataPlot <- rbind(dataPlot, newDataPlot)
}
###
### Plot
###
ggplot(dataPlot, aes(x = a, y  = value, group = group)) +
geom_line(aes(linetype = type)) +
labs(y = "", linetype = "", x = "") +
facet_wrap(~parameter, ncol = 2, scales = "free") +
theme(legend.position = c(7/8, 1/8), legend.justification = c(1, 0))
bitmap("pics/FitKEFire.tiff",res = 300, width = 5,height = 5)
plot<-ggplot(dataPlot, aes(x = a, y  = value, group = group)) +
geom_line(aes(linetype = type)) +
labs(y = "", linetype = "", x = "") +
facet_wrap(~parameter, ncol = 2, scales = "free") +
theme(legend.position = c(7/8, 1/8), legend.justification = c(1, 0))
dev.off()
# The command below only works for Mac OS X systems
# It converts to a png format without loss
# system("sips -s format png pics/FitKEFire.tiff --out pics/FitKEFire.png")
ggsave(plot,file = "pics/Figure13_FitKEFire.svg")
ggsave(plot,file = "pics/Figure13_FitKEFire.svg", width = 5,height = 5,dpi=300)
library(DistributionPty)
DistributionPty::Dlnorm(a,0,meanlog,sdlog)
remove(list = ls())
library(svglite)
library(ggplot2)
library(plyr)
library(dplyr)
# Load data
load("data/syntDatalogNormal.RData")
meanlog <- 0
sdlog <- 0.5
load("data/syntDatalogNormalCI.RData")
dataPlot <- NULL
for (i in 1:length(CI))
{
a <- CI[[i]]$a
truth <- c(DistributionPty::Dlnorm(a,2,meanlog,sdlog),
DistributionPty::Dlnorm(a,1,meanlog,sdlog),
1 - DistributionPty::Dlnorm(a,0,meanlog,sdlog))
newDataPlot <- data.frame(a = a,
parameter = rep(c("Density derivative function", "Density function", "Tail distribution function"),3),
value = as.numeric(c(CI[[i]]$hyperrectangle[1,], CI[[i]]$hyperrectangle[2,], truth)),
group =  rep(c("lB","uB","truth"),each = 3),
type = c(rep("Boostrap 95% CI", 6), rep("True function",3)))
dataPlot <- rbind(dataPlot, newDataPlot)
}
ggplot(dataPlot, aes(x = a, y  = value, group = group)) +
geom_line(aes(linetype = type)) +
labs(y = "", linetype = "", x = "") +
facet_wrap(~parameter, ncol = 2, scales = "free") +
theme(legend.position = c(7/8, 1/8), legend.justification = c(1, 0))
meanlog
sdlog
a
CI[[i]]$a
CI[[30]
]
CI[[30]]$a
library(DistributionPty)
dataPlot <- NULL
for (i in 1:length(CI))
{
a <- CI[[i]]$a
truth <- c(DistributionPty::Dlnorm(a,2,meanlog,sdlog),
DistributionPty::Dlnorm(a,1,meanlog,sdlog),
1 - DistributionPty::Dlnorm(a,0,meanlog,sdlog))
newDataPlot <- data.frame(a = a,
parameter = rep(c("Density derivative function", "Density function", "Tail distribution function"),3),
value = as.numeric(c(CI[[i]]$hyperrectangle[1,], CI[[i]]$hyperrectangle[2,], truth)),
group =  rep(c("lB","uB","truth"),each = 3),
type = c(rep("Boostrap 95% CI", 6), rep("True function",3)))
dataPlot <- rbind(dataPlot, newDataPlot)
}
##
## Plot CI's
##
bitmap("pics/FitKEModelLogNorm.tiff",res = 300, width = 5,height = 5)
plot<-ggplot(dataPlot, aes(x = a, y  = value, group = group)) +
geom_line(aes(linetype = type)) +
labs(y = "", linetype = "", x = "") +
facet_wrap(~parameter, ncol = 2, scales = "free") +
theme(legend.position = c(7/8, 1/8), legend.justification = c(1, 0))
library(svglite)
library(ggplot2)
library(plyr)
library(dplyr)
# Load data
load("data/syntDatalogNormal.RData")
meanlog <- 0
sdlog <- 0.5
dataPlot <- NULL
for (i in 1:length(CI))
{
a <- CI[[i]]$a
truth <- c(DistributionPty::Dlnorm(a,2,meanlog,sdlog),
DistributionPty::Dlnorm(a,1,meanlog,sdlog),
1 - DistributionPty::Dlnorm(a,0,meanlog,sdlog))
newDataPlot <- data.frame(a = a,
parameter = rep(c("Density derivative function", "Density function", "Tail distribution function"),3),
value = as.numeric(c(CI[[i]]$hyperrectangle[1,], CI[[i]]$hyperrectangle[2,], truth)),
group =  rep(c("lB","uB","truth"),each = 3),
type = c(rep("Boostrap 95% CI", 6), rep("True function",3)))
dataPlot <- rbind(dataPlot, newDataPlot)
}
plot<-ggplot(dataPlot, aes(x = a, y  = value, group = group)) +
geom_line(aes(linetype = type)) +
labs(y = "", linetype = "", x = "") +
facet_wrap(~parameter, ncol = 2, scales = "free") +
theme(legend.position = c(7/8, 1/8), legend.justification = c(1, 0))
plot
dev.off
dev.off()
dev.off()
ggplot(dataPlot, aes(x = a, y  = value, group = group)) +
geom_line(aes(linetype = type)) +
labs(y = "", linetype = "", x = "") +
facet_wrap(~parameter, ncol = 2, scales = "free") +
theme(legend.position = c(7/8, 1/8), legend.justification = c(1, 0))
library(DistributionPty)
dataPlot <- NULL
for (i in 1:length(CI))
{
a <- CI[[i]]$a
truth <- c(DistributionPty::Dlnorm(a,2,meanlog,sdlog),
DistributionPty::Dlnorm(a,1,meanlog,sdlog),
1 - DistributionPty::Dlnorm(a,0,meanlog,sdlog))
newDataPlot <- data.frame(a = a,
parameter = rep(c("Density derivative function", "Density function", "Tail distribution function"),3),
value = as.numeric(c(CI[[i]]$hyperrectangle[1,], CI[[i]]$hyperrectangle[2,], truth)),
group =  rep(c("lB","uB","truth"),each = 3),
type = c(rep("Boostrap 95% CI", 6), rep("True function",3)))
dataPlot <- rbind(dataPlot, newDataPlot)
}
ggplot(dataPlot, aes(x = a, y  = value, group = group)) +
geom_line(aes(linetype = type)) +
labs(y = "", linetype = "", x = "") +
facet_wrap(~parameter, ncol = 2, scales = "free") +
theme(legend.position = c(7/8, 1/8), legend.justification = c(1, 0))
library(svglite)
library(ggplot2)
library(plyr)
library(dplyr)
ggplot(dataPlot, aes(x = a, y  = value, group = group)) +
geom_line(aes(linetype = type)) +
labs(y = "", linetype = "", x = "") +
facet_wrap(~parameter, ncol = 2, scales = "free") +
theme(legend.position = c(7/8, 1/8), legend.justification = c(1, 0))
x <- seq(1,10,by = 0.01)
plot(x,(1+x)/(x^2*exp(x)))
plot(x,(1+x)/(x^2*exp(x)),type="l")
remove(list = ls())
###
### Compute the optimal upper bound using program (EC.19)
###
load("data/datafireinsuranceCI.RData")
remove(list = ls())
load("data/datafireinsurance.RData")
sum(sample >= 29.03)
sample >= 29.03
sample
sample$Loss.in.DKM >= 29.03
sum(sample$Loss.in.DKM >= 29.03)
remove(list= ls())
# Create the data for the plot
library(DistributionPty)
library(dplyr)
shape = scale = 1
load("data/runSyntheticPareto.RData")
widthRect <- diff(ppareto(optimBound$a, shape,scale)[1:2])
dataPlot <- transform(optimBound,
aLperc = ppareto(a, shape,scale),
aUperc = ppareto(a, shape,scale) + widthRect,
pc = ppareto(c, shape,scale),
pd = ppareto(d, shape,scale),
truth =  ppareto(d, shape,scale) - ppareto(c, shape,scale)) %>%
transform(ratio = bound/truth)
# Create the Plot
bitmap("pics/runSyntheticPareto.tiff",res = 300, width = 5,height = 5)
library(ggplot2)
plot <- ggplot(dataPlot, aes(xmin = aLperc, xmax = aUperc,  ymin = pc, ymax = pd, fill = ratio)) +
geom_rect(colour = "white") +
scale_fill_gradient(low = "white", high = "black") +
scale_x_continuous(breaks = seq(0.7,0.86, length = 9),expand=c(0,0)) +
scale_y_continuous(breaks = seq(0.86,0.98, length = 7),expand=c(0,0)) +
labs(y = "Interval (c,d) in percentile",
x = "Threshold a in percentile",
fill = "Ratio between the optimal upper bound and the true value")  +
guides(fill = guide_colorbar(barwidth = 0.5, barheight = 20, title.position = "right"))+
theme(legend.title = element_text(angle = 90))
ggsave(plot,file= "pics/runSyntheticPareto.svg",res = 300, width = 5,height = 5)
dev.off()
system("sips -s format png pics/runSyntheticPareto.tiff --out pics/runSyntheticPareto.png")
plot
plot <- ggplot(dataPlot, aes(xmin = aLperc, xmax = aUperc,  ymin = pc, ymax = pd, fill = ratio)) +
geom_rect(colour = "white") +
scale_fill_gradient(low = "white", high = "black") +
scale_x_continuous(breaks = seq(0.7,0.86, length = 9),expand=c(0,0)) +
scale_y_continuous(breaks = seq(0.86,0.98, length = 7),expand=c(0,0)) +
labs(y = "Interval (c,d) in percentile",
x = "Threshold a in percentile",
fill = "Ratio between the optimal upper bound and the true value")  +
guides(fill = guide_colorbar(barwidth = 0.5, barheight = 20, title.position = "right"))+
theme(legend.title = element_text(angle = 90))
plot
remove(list= ls())
# Create the data for the plot
library(DistributionPty)
library(dplyr)
library(ggplot2)
library(svglite)
shape = scale = 1
load("data/runSyntheticPareto.RData")
widthRect <- diff(ppareto(optimBound$a, shape,scale)[1:2])
dataPlot <- transform(optimBound,
aLperc = ppareto(a, shape,scale),
aUperc = ppareto(a, shape,scale) + widthRect,
pc = ppareto(c, shape,scale),
pd = ppareto(d, shape,scale),
truth =  ppareto(d, shape,scale) - ppareto(c, shape,scale)) %>%
transform(ratio = bound/truth)
plot <- ggplot(dataPlot, aes(xmin = aLperc, xmax = aUperc,  ymin = pc, ymax = pd, fill = ratio)) +
geom_rect(colour = "white") +
scale_fill_gradient(low = "white", high = "black") +
scale_x_continuous(breaks = seq(0.7,0.86, length = 9),expand=c(0,0)) +
scale_y_continuous(breaks = seq(0.86,0.98, length = 7),expand=c(0,0))
plot
dataPlot
ggplot(dataPlot, aes(xmin = aLperc, xmax = aUperc,  ymin = pc, ymax = pd, fill = ratio)) +
geom_rect(colour = "white")
remove(list= ls())
# Create the data for the plot
library(DistributionPty)
library(dplyr)
library(ggplot2)
library(svglite)
shape <- 2
rate <- 1
#load("data/runSyntheticGamma.RData")
load("R/7.1. Elementary Examples/Tail Interval Probability/Gamma/runSyntheticGamma.RData")
widthRect <- diff(pgamma(optimBound$a, shape,rate)[1:2])
dataPlot <- transform(optimBound,
aLperc = pgamma(a, shape,rate),
aUperc = pgamma(a, shape,rate) + widthRect,
pc = pgamma(c, shape,rate),
pd = pgamma(d, shape,rate),
truth =  pgamma(d, shape,rate) - pgamma(c, shape,rate)) %>%
transform(ratio = bound/truth)
remove(list= ls())
# Create the data for the plot
library(DistributionPty)
library(dplyr)
library(ggplot2)
library(svglite)
shape <- 2
rate <- 1
load("data/runSyntheticGamma.RData")
widthRect <- diff(pgamma(optimBound$a, shape,rate)[1:2])
dataPlot <- transform(optimBound,
aLperc = pgamma(a, shape,rate),
aUperc = pgamma(a, shape,rate) + widthRect,
pc = pgamma(c, shape,rate),
pd = pgamma(d, shape,rate),
truth =  pgamma(d, shape,rate) - pgamma(c, shape,rate)) %>%
transform(ratio = bound/truth)
ggplot(dataPlot, aes(xmin = aLperc, xmax = aUperc,  ymin = pc, ymax = pd, fill = ratio)) +
geom_rect(colour = "white")
