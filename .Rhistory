remove(list = ls())
library(dplyr)
library(plyr)
library(parallel)
# Compute the optimal upper bound for various values of eta, nu, beta
load ("data/syntDatalogNormalCI.RData")
# Get the bootstrapped sample obtained to build the CI's
# and compute point estimates
bootSample <- CI[[55]]$bootSample
Fhat <- apply(bootSample, 2,mean)
etaCI <- CI[[55]]$hyperrectangle$d1
betaCI <- CI[[55]]$hyperrectangle$m0
nuCI <- -CI[[55]]$hyperrectangle$d2
parameters <- expand.grid(eta = c(etaCI, Fhat[2]),
beta = c(betaCI, Fhat[3]),
nu = c(rev(nuCI), -Fhat[1])) %>%
transform(mu = eta/nu,  sigma =  2*beta/nu) %>%
transform(feasible = mu^2 <= sigma)
# Parameters of the problem
c <- 4
d <- 5
a <- CI[[55]]$a# A index is 55 (compare to the full vector a)  # See Analysis Synthetic Log Normal to get this
H <- function(x) output <- 1/2*( (x+a -c)^2*(x+a>=c) - (x+a -d)^2*(x+a>=d))*(x >=a)
runFunc <- function(nu,mu,sigma){
bound <- RobustTail::computeBound(H, mu, sigma, lambda = 0, nu = nu)$bound
output <- data.frame(bound = bound)
return(output)
}
remove(list = ls())
library(dplyr)
library(plyr)
library(parallel)
# Compute the optimal upper bound for various values of eta, nu, beta
load ("data/syntDatalogNormalCI.RData")
# Get the bootstrapped sample obtained to build the CI's
# and compute point estimates
bootSample <- CI[[55]]$bootSample
Fhat <- apply(bootSample, 2,mean)
etaCI <- CI[[55]]$hyperrectangle$d1
betaCI <- CI[[55]]$hyperrectangle$m0
nuCI <- -CI[[55]]$hyperrectangle$d2
parameters <- expand.grid(eta = c(etaCI, Fhat[2]),
beta = c(betaCI, Fhat[3]),
nu = c(rev(nuCI), -Fhat[1])) %>%
transform(mu = eta/nu,  sigma =  2*beta/nu) %>%
transform(feasible = mu^2 <= sigma)
# Parameters of the problem
c <- 4
d <- 5
a <- CI[[55]]$a# A index is 55 (compare to the full vector a)  # See Analysis Synthetic Log Normal to get this
H <- function(x) output <- 1/2*( (x+a -c)^2*(x+a>=c) - (x+a -d)^2*(x+a>=d))*(x >=a)
runFunc <- function(nu,mu,sigma){
bound <- RobustTail::computeBound(H, mu, sigma, lambda = 0, nu = nu)$bound
output <- data.frame(bound = bound)
return(output)
}
optimBound <- ldply(with(parameters, mcmapply(FUN = runFunc,
mu = mu,
sigma = sigma,
nu = nu,
mc.cores = 4, # The number of cores can be increases to run computation in parallel
SIMPLIFY = FALSE)))
remove(list = ls())
library(dplyr)
library(plyr)
library(parallel)
# Compute the optimal upper bound for various values of eta, nu, beta
load ("data/syntDatalogNormalCI.RData")
# and compute point estimates
bootSample <- CI[[55]]$bootSample
Fhat <- apply(bootSample, 2,mean)
etaCI <- CI[[55]]$hyperrectangle$d1
betaCI <- CI[[55]]$hyperrectangle$m0
nuCI <- -CI[[55]]$hyperrectangle$d2
parameters <- expand.grid(eta = c(etaCI, Fhat[2]),
beta = c(betaCI, Fhat[3]),
nu = c(rev(nuCI), -Fhat[1])) %>%
transform(mu = eta/nu,  sigma =  2*beta/nu) %>%
transform(feasible = mu^2 <= sigma)
remove(list = ls())
library(dplyr)
library(plyr)
library(parallel)
# Compute the optimal upper bound for various values of eta, nu, beta
load ("data/syntDatalogNormalCI.RData")
setwd("/src/BU/MyNoteBooks/ORpaper/")
library(dplyr)
library(plyr)
library(parallel)
# Compute the optimal upper bound for various values of eta, nu, beta
load ("data/syntDatalogNormalCI.RData")
# Get the bootstrapped sample obtained to build the CI's
# and compute point estimates
bootSample <- CI[[55]]$bootSample
Fhat <- apply(bootSample, 2,mean)
etaCI <- CI[[55]]$hyperrectangle$d1
betaCI <- CI[[55]]$hyperrectangle$m0
nuCI <- -CI[[55]]$hyperrectangle$d2
parameters <- expand.grid(eta = c(etaCI, Fhat[2]),
beta = c(betaCI, Fhat[3]),
nu = c(rev(nuCI), -Fhat[1])) %>%
transform(mu = eta/nu,  sigma =  2*beta/nu) %>%
transform(feasible = mu^2 <= sigma)
# Parameters of the problem
c <- 4
d <- 5
a <- CI[[55]]$a# A index is 55 (compare to the full vector a)  # See Analysis Synthetic Log Normal to get this
H <- function(x) output <- 1/2*( (x+a -c)^2*(x+a>=c) - (x+a -d)^2*(x+a>=d))*(x >=a)
runFunc <- function(nu,mu,sigma){
bound <- RobustTail::computeBound(H, mu, sigma, lambda = 0, nu = nu)$bound
output <- data.frame(bound = bound)
return(output)
}
optimBound <- ldply(with(parameters, mcmapply(FUN = runFunc,
mu = mu,
sigma = sigma,
nu = nu,
mc.cores = 4, # The number of cores can be increases to run computation in parallel
SIMPLIFY = FALSE)))
# Create Table 2 in Latex exportable format
library(xtable)
typeValue <- c("Lower bound", "Upper bound", "Estimated value")
dataTable <-  expand.grid(eta = typeValue,
beta = typeValue,
nu =   typeValue) %>%
transform(bound = optimBound) %>%
filter(is.finite(bound)) %>%
arrange(bound)
names(dataTable) <-c("$ \\eta$", "$ \\beta$", "$ \\nu$", "Optimal upper bound")
caption <- "Sensitivity analysis of the optimal upper bound of $P(4<X<5)$ for the synthetic data in Example \\ref{example:synthetic}."
label <- "Tab:Ex SyntD  sensitivity"
display <- c("d","s","s","s","E")
align  <- rep("c",length(display))
xtable(dataTable, caption = caption , label = label, display = display, align = align)
# Create Table 2 in Latex exportable format
library(xtable)
typeValue <- c("Lower bound", "Upper bound", "Estimated value")
dataTable <-  expand.grid(eta = typeValue,
beta = typeValue,
nu =   typeValue) %>%
transform(bound = optimBound) %>%
filter(is.finite(bound)) %>%
arrange(bound)
names(dataTable) <-c("$ \\eta$", "$ \\beta$", "$ \\nu$", "Optimal upper bound")
caption <- "Sensitivity analysis of the optimal upper bound of $P(4<X<5)$ for the synthetic data in Example \\ref{example:synthetic}."
label <- "Tab:Ex SyntD  sensitivity"
display <- c("d","s","s","s","E")
align  <- rep("c",length(display))
xtable(dataTable, caption = caption , label = label, display = display, align = align) %>%
print(include.rownames=FALSE, type = "latex", sanitize.text.function = identity, file = "tables/logNormalSensitivity.tex")
remove(list = ls())
load ("data/syntDatalogNormalCI.RData")
load("data/syntDatalogNormal.RData")
# Parameters of the problem
c <- 4
d <- 5
a <- CI[[55]]$a# A index is 55 (compare to the full vector a)  # See Analysis Synthetic Log Normal to get this
H <- function(x) output <- 1/2*( (x+a -c)^2*(x+a>=c) - (x+a -d)^2*(x+a>=d))*(x >=a)
# Case 1 : Data driven optimal bound
etaCI <- CI[[55]]$hyperrectangle$d1
betaCI <- CI[[55]]$hyperrectangle$m0
nuCI <- -CI[[55]]$hyperrectangle$d2[1]
muCI <- etaCI/nuCI
sigmaCI <- 2*betaCI/nuCI
optimBoundCI <- RobustTail::computeBound(H, muCI, sigmaCI, lambda = 0, nuCI)
# Case 2 : True parameters optimal bound
library(DistributionPty)
meanlog <- 0
sdlog <- 0.5
beta <- 1 - plnorm(a,meanlog,sdlog)
eta <- Dlnorm(a,1,meanlog,sdlog)
nu <- -Dlnorm(a,2, meanlog,sdlog)
mu <- eta/nu
sigma <- 2*beta/nu
optimBoundVal <- RobustTail::computeBound(H, mu, sigma, lambda = 0,  nu)
# Case 3 : GPD approach
library(dplyr)
u <- 1.8
QRM::MEplot(sample) %>% abline(v = u) # Choose the threshold
fitGPD <- QRM::fit.GPD(sample,threshold = u,type = "ml") # Fit the GPD
h <- function(xi, beta) QRM::pGPD(d -u,xi,beta) - QRM::pGPD(c -u,xi,beta)
hGrad <- function(xi,beta) gradientpGPD(d-u,xi,beta) - gradientpGPD(c-u,xi,beta)
GPDbound <- asymptoticCIforGPDfit(fitGPD,h,hGrad,verbose = FALSE) # Compute the CI
# Create Table 1 in Latex exportable format
library(xtable)
Fn <- ecdf(sample)
truth <- diff(plnorm(c(c,d),meanlog,sdlog))
table <- data.frame(c("Truth","ECDF", "GPD","Worst-case with known parameters", "Worst-case appoach"),
c(truth, Fn(c) - Fn(d), GPDbound$uB, optimBoundVal$bound, optimBoundCI$bound))
names(table)<- c("Method", "Estimated upper bound")
caption <- "Estimated upper bounds of the probability $P(4<X<5)$ for the synthetic data in Example \\ref{example:synthetic}."
label <- "Tab:Ex SyntD"
display <- c("d","s","E")
align  <- rep("c",length(display))
xtable(table, caption = caption , label = label, display = display, align = align) %>%
print(include.rownames=FALSE, type = "latex",file = "tables/logNormal45.tex")
xtable(table, caption = caption , label = label, display = display, align = align)
2^6
2^6 + 2^3 + 2^2 + 1
2^4 + 2^1 + 2^0
###
### The goal of this function is to fit a mixture of Shifted Pareto and 2-PLT
### that is feasible for program (1), i.e. we find two distribution functions
### F1 and F2 such that
###
### w1 + w2 = 1
### w1 f1(a) + w2 f2(a) = eta
### - w1 f1'(a) - w2 f2'(a) = nu
### w1 (1 - F1(a)) + w2 (1- F2(a)) = beta
###
### where
###  * F1(x) is a two point mass distribution function (2-PLT)
###  * F2 is a pareto distribution, i.e. F2(x) = 1 - (scale/x)^shape for all x => scale
###  and the shape is a number between 0 and 2
###
### The problem of finding such distribution functions is equivalent to finding
### F2(x) such that
###
### eta1 = f1(a) = (eta - w2 f2(a))/w1 = (eta - w2 eta2(a))/w1  => 0
### nu1 = -f1'(a) = (nu + w2 f2'(a))/w1 = (nu - w2 nu2(a))/w1 => 0
### beta1 =  (beta - w2 (1 - F2(a)))/w1  = (beta - w2 beta2)/w1 => 0
###
### and
###
### mu1^2 = (eta1/nu1)^2 <= sigma1 = 2*beta1/nu1
###
### If there exist a pareto distribution F2(x) such that the 3 previous
### equalities and the inequality hold, then there exists a 2-PLT distribution whose
### key parameters (x1,x2) and (p1,p2), as given in Equation (6), can
### be obtained using the function "getDistribution" available in the package "RobustTail"
###
fitMixturePareto2PLT <- function(a,nu,eta,beta, iterMax = 1E4,seed = NULL)
{
mu <- eta/nu
sigma <- 2*beta/nu
for (i in 1:iterMax){
# Assign randomly w2 and the shape of F2(x)
if (!is.null(seed)) set.seed(seed)
w2 <- runif(1,0, 1)
if (!is.null(seed)) set.seed(seed)
shape <- runif(1,0,2)
w1 <- (1-w2)
# Compute the necessary (but not sufficient) bounds on the X =
# (x/scale)^(-shape) of F2(x) for there existence of F1(x)
b <- mu*a*shape - (shape+1)*shape*sigma/2  - a^2
fourac <- shape*(shape+2)*a^2*(sigma-mu^2)
delta <- b^2 - fourac
XuB <- min(c(1,beta/w2, eta*a/(w2*shape), nu*a^2/(w2*shape*shape+1)))
XlB <- if (delta >= 0) max(c(nu/(4*w2)*(b + sqrt(delta)), 0)) else 0
if (!is.null(seed)) set.seed(seed)
# Get a random value of X respecting the bounds
X <- runif(1,XlB,XuB)
# From X we obtain the scale
scale <- X^(1/shape)*a
# We now need to compute eta1, beta1, and nu1
# to check if there exists a 2-PLT F1(x) for
# this specific F2(x)
eta2 <- DistributionPty::Dpareto(a, d = 1, scale,shape)
nu2 <- -DistributionPty::Dpareto(a, d = 2, scale,shape)
beta2 <- 1 - DistributionPty::ppareto(a, scale,shape)
eta1 <- (eta -  w2*eta2)/w1
nu1 <- (nu -  w2*nu2)/w1
beta1 <- (beta -  w2*beta2)/w1
mu1 <- eta1/nu1
sigma1 <- 2*beta1/nu1
# Check the necesserary condition for the existence
# of F1(x)
if (mu1^2 <= sigma1) break
}
if (i > iterMax) return("No solution")
P <- RobustTail::getDistribution(mu1,sigma2)
Pareto <- list(scale = scale,
shape = shape,
eta = eta2,
nu = nu2,
beta = beta2,
w = w2)
PLT <- list(x = P$x,
p = P$p,
w = w1,
nu = nu1,
eta = eta1,
beta = beta1)
output <- list(Pareto = Pareto, PLT = PLT)
return(output)
}
a <- qexp(0.7)
eta <- dexp(a)
nu <- dexp(a)
beta <- 1 - pexp(a)
mixture <- fitMixturePareto2PLT(a,nu,eta,beta, seed = 100)
fitMixturePareto2PLT <- function(a,nu,eta,beta, iterMax = 1E4,seed = NULL)
{
mu <- eta/nu
sigma <- 2*beta/nu
for (i in 1:iterMax){
# Assign randomly w2 and the shape of F2(x)
if (!is.null(seed)) set.seed(seed)
w2 <- runif(1,0, 1)
if (!is.null(seed)) set.seed(seed)
shape <- runif(1,0,2)
w1 <- (1-w2)
# Compute the necessary (but not sufficient) bounds on the X =
# (x/scale)^(-shape) of F2(x) for there existence of F1(x)
# XuB is an upper bound on X that ensures that
# eta1, nu1, and beta1 => 0
XuB <- min(c(1,beta/w2, eta*a/(w2*shape), nu*a^2/(w2*shape*shape+1)))
# we now compute XlB, a necessary lower bound for mu1^1 <= sigma1
b <- mu*a*shape - (shape+1)*shape*sigma/2  - a^2
fourac <- shape*(shape+2)*a^2*(sigma-mu^2)
delta <- b^2 - fourac
XlB <- if (delta >= 0) max(c(nu/(4*w2)*(b + sqrt(delta)), 0)) else 0
# Get a random value of X respecting the bounds
# and derive the value of the scale parameter in F2(x)
if (!is.null(seed)) set.seed(seed)
X <- runif(1,XlB,XuB)
scale <- X^(1/shape)*a
# We now need to compute eta1, beta1, and nu1
# to check if there exists a 2-PLT F1(x) for
# this specific F2(x)
eta2 <- DistributionPty::Dpareto(a, d = 1, scale,shape)
nu2 <- -DistributionPty::Dpareto(a, d = 2, scale,shape)
beta2 <- 1 - DistributionPty::ppareto(a, scale,shape)
eta1 <- (eta -  w2*eta2)/w1
nu1 <- (nu -  w2*nu2)/w1
beta1 <- (beta -  w2*beta2)/w1
mu1 <- eta1/nu1
sigma1 <- 2*beta1/nu1
# Check the necesserary condition for the existence
# of F1(x)
if (mu1^2 <= sigma1) break
}
if (i > iterMax) return("No solution")
P <- RobustTail::getDistribution(mu1,sigma1)
Pareto <- list(scale = scale,
shape = shape,
eta = eta2,
nu = nu2,
beta = beta2,
w = w2)
PLT <- list(x = P$x,
p = P$p,
w = w1,
nu = nu1,
eta = eta1,
beta = beta1)
output <- list(Pareto = Pareto, PLT = PLT)
return(output)
}
mixture <- fitMixturePareto2PLT(a,nu,eta,beta, seed = 100)
mixture
mixture$PLT
with(mixture, with(Pareto, w*nu) + with(PLT, w*nu))
with(mixture, data.frame( nu = with(Pareto, w*nu) + with(PLT, w*nu),
###                           eta = with(Pareto, w*eta) + with(PLT, w*eta),
###                           beta = with(Pareto, w*beta) + with(PLT, w*beta))
with(mixture, data.frame( nu = with(Pareto, w*nu) + with(PLT, w*nu),}
with(mixture, data.frame( nu = with(Pareto, w*nu) + with(PLT, w*nu),
eta = with(Pareto, w*eta) + with(PLT, w*eta),
beta = with(Pareto, w*beta) + with(PLT, w*eta))
)
with(mixture, data.frame( nu = with(Pareto, w*nu) + with(PLT, w*nu),
eta = with(Pareto, w*eta) + with(PLT, w*eta),
beta = with(Pareto, w*beta) + with(PLT, w*beta))
)
a <- qexp(0.7)
eta <- dexp(a)
nu <- dexp(a)
beta <- 1 - pexp(a)
mixture <- fitMixturePareto2PLT(a,nu,eta,beta)
# Check the system
with(mixture, data.frame( nu = with(Pareto, w*nu) + with(PLT, w*nu),
eta = with(Pareto, w*eta) + with(PLT, w*eta),
beta = with(Pareto, w*beta) + with(PLT, w*beta)))
a <- qexp(0.7)
eta <- dexp(a)
nu <- dexp(a)
beta <- 1 - pexp(a)
mixture <- fitMixturePareto2PLT(a,nu,eta,beta)
# Check the system
with(mixture, data.frame( nu = with(Pareto, w*nu) + with(PLT, w*nu),
eta = with(Pareto, w*eta) + with(PLT, w*eta),
beta = with(Pareto, w*beta) + with(PLT, w*beta)))
a <- qexp(0.7)
eta <- dexp(a)
nu <- dexp(a)
beta <- 1 - pexp(a)
mixture <- fitMixturePareto2PLT(a,nu,eta,beta)
# Check the system
with(mixture, data.frame( nu = with(Pareto, w*nu) + with(PLT, w*nu),
eta = with(Pareto, w*eta) + with(PLT, w*eta),
beta = with(Pareto, w*beta) + with(PLT, w*beta)))
a <- qexp(0.7)
eta <- dexp(a)
nu <- dexp(a)
beta <- 1 - pexp(a)
mixture <- fitMixturePareto2PLT(a,nu,eta,beta)
# Check the system
with(mixture, data.frame( nu = with(Pareto, w*nu) + with(PLT, w*nu),
eta = with(Pareto, w*eta) + with(PLT, w*eta),
beta = with(Pareto, w*beta) + with(PLT, w*beta)))
mixture
with(mixture, data.frame( nu = with(Pareto, nu>= 0) & with(PLT, nu >= 0),
eta =with(Pareto, eta >= 0) & with(PLT, eta >= 0),
beta = with(Pareto, beta>= 0) & with(PLT, beta >= 0)))
a <- qexp(0.7)
eta <- dexp(a)
nu <- dexp(a)
beta <- 1 - pexp(a)
mixture <- fitMixturePareto2PLT(a,nu,eta,beta)
mixture
a <- qexp(0.7)
eta <- dexp(a)
nu <- dexp(a)
beta <- 1 - pexp(a)
mixture <- fitMixturePareto2PLT(a,nu,eta,beta)
mixture
a <- qexp(0.7)
eta <- dexp(a)
nu <- dexp(a)
beta <- 1 - pexp(a)
mixture <- fitMixturePareto2PLT(a,nu,eta,beta)
mixture
?dnorm
Dpareto  = function(x,d,scale=1,shape=1)
{
if (!is.integer(d) || d < 0) return("d must be a non-negative integer.")
if (scale <= 0 || shape <= 0 ) return("The scale and shape parameters must be positive numbers.")
derivative <- rep(NA,length(x))
derivative[x < scale] <- 0
xs <- x[x >= scale]
if (d == 0) derivative[x >= scale] <- ppareto(xs,scale,shape)
if (d != 0) derivative[x >= scale] <- -(-1/scale)^(d)*(xs/scale)^(-shape-d)*prod(shape + 0:(d-1))
output <- derivative
return(output)
}
Dpareto <- function(x,d,scale=1,shape=1)
{
if (!is.integer(d) || d < 0) return("d must be a non-negative integer.")
if (scale <= 0 || shape <= 0 ) return("The scale and shape parameters must be positive numbers.")
derivative <- rep(NA,length(x))
derivative[x < scale] <- 0
xs <- x[x >= scale]
if (d == 0) derivative[x >= scale] <- ppareto(xs,scale,shape)
if (d != 0) derivative[x >= scale] <- -(-1/scale)^(d)*(xs/scale)^(-shape-d)*prod(shape + 0:(d-1))
output <- derivative
return(output)
}
Dpareto(x,-1,scale=1,shape=1)
Dpareto(x,1,scale=-1,shape=1)
d %% d
round(d)
round(d) == d
round(3.5) == 3.5
round(4) == 4
is.integer(4)
Dpareto <- function(x,d,scale=1,shape=1)
{
if (round(d) == d || d < 0) return("d must be a non-negative integer.")
if (scale <= 0 || shape <= 0 ) return("The scale and shape parameters must be positive numbers.")
derivative <- rep(NA,length(x))
derivative[x < scale] <- 0
xs <- x[x >= scale]
if (d == 0) derivative[x >= scale] <- ppareto(xs,scale,shape)
if (d != 0) derivative[x >= scale] <- -(-1/scale)^(d)*(xs/scale)^(-shape-d)*prod(shape + 0:(d-1))
output <- derivative
return(output)
}
Dpareto(x,1,scale=-1,shape=1)
round(1)==1
Dpareto <- function(x,d,scale=1,shape=1)
{
if (round(d) == d || d < 0) return("d must be a non-negative integer.")
if (scale <= 0 || shape <= 0 ) return("The scale and shape parameters must be positive numbers.")
derivative <- rep(NA,length(x))
derivative[x < scale] <- 0
xs <- x[x >= scale]
if (d == 0) derivative[x >= scale] <- ppareto(xs,scale,shape)
if (d != 0) derivative[x >= scale] <- -(-1/scale)^(d)*(xs/scale)^(-shape-d)*prod(shape + 0:(d-1))
output <- derivative
return(output)
}
Dpareto(x,1,scale=-1,shape=1)
Dpareto(x,d = 1,scale=-1,shape=1)
